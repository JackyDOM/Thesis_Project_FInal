from flask import Flask, render_template, request
from flask_sqlalchemy import SQLAlchemy
from flask_restx import Api, Resource, fields, Namespace

# Initialize Flask app
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize SQLAlchemy
db = SQLAlchemy(app)

# Initialize Flask-RESTX API
api = Api(app, version='1.0', title='My API', description='A simple API', doc='/swagger/')

# Define the User model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    age = db.Column(db.Integer, nullable=False)
    genre = db.Column(db.String(50), nullable=False)
    dob = db.Column(db.String(50), nullable=False)
    personality = db.Column(db.String(100), nullable=False)
    job = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(500), nullable=False)

    def __init__(self, name, age, genre, dob, personality, job, description):
        self.name = name
        self.age = age
        self.genre = genre
        self.dob = dob
        self.personality = personality
        self.job = job
        self.description = description

# Create a namespace for User Information
user_ns = Namespace('User_Information', description='Operations related to user information')
api.add_namespace(user_ns)

# Define the user model for Swagger UI input validation
user_input_model = user_ns.model('User', {
    'name': fields.String(required=True, description='Name of the user'),
    'age': fields.Integer(required=True, description='Age of the user'),
    'genre': fields.String(required=True, description='Genre of the user'),
    'dob': fields.String(required=True, description='Date of birth'),
    'personality': fields.String(required=True, description='Personality description'),
    'job': fields.String(required=True, description='Job description'),
    'description': fields.String(required=True, description='Short description of the user')
})

# User Resource for POST (create user)
@user_ns.route('/user')
class UserResource(Resource):
    @user_ns.expect(user_input_model)
    @user_ns.doc('create_user')
    def post(self):
        """Create new user information"""
        data = request.get_json()
        
        # Check if user with the same name already exists
        if User.query.filter_by(name=data['name']).first():
            return {'message': f'User with name {data["name"]} already exists'}, 400
        
        # Create and save the new user
        user = User(
            name=data['name'],
            age=data['age'],
            genre=data['genre'],
            dob=data['dob'],
            personality=data['personality'],
            job=data['job'],
            description=data['description']
        )
        db.session.add(user)
        db.session.commit()
        
        return {'message': f'User {user.name} created successfully'}, 201

# User Resource by ID for GET, PUT, DELETE
@user_ns.route('/user/<int:user_id>')
class UserResourceById(Resource):
    def get(self, user_id):
        """Retrieve user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        return {
            'id': user.id,
            'name': user.name,
            'age': user.age,
            'genre': user.genre,
            'dob': user.dob,
            'personality': user.personality,
            'job': user.job,
            'description': user.description
        }, 200

    @user_ns.expect(user_input_model)
    def put(self, user_id):
        """Update existing user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        data = request.get_json()
        user.name = data['name']
        user.age = data['age']
        user.genre = data['genre']
        user.dob = data['dob']
        user.personality = data['personality']
        user.job = data['job']
        user.description = data['description']
        db.session.commit()
        return {'message': f'User {user_id} updated successfully'}, 200

    def delete(self, user_id):
        """Delete user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        db.session.delete(user)
        db.session.commit()
        return {'message': f'User {user_id} deleted successfully'}, 200

# User List Resource for GET (all users)
@user_ns.route('/users')
class UserList(Resource):
    def get(self):
        """Retrieve all user information"""
        users = User.query.all()
        if not users:
            return {'message': 'No users found', 'code': 404}, 404

        users_list = []
        for user in users:
            users_list.append({
                'id': user.id,
                'name': user.name,
                'age': user.age,
                'genre': user.genre,
                'dob': user.dob,
                'personality': user.personality,
                'job': user.job,
                'description': user.description
            })
        
        response = {
            'message': 'All user information retrieved successfully',
            'code': 200,
            'data': users_list
        }
        return response, 200

# Dashboard route
@app.route('/dashboard')
def dashboard():
    return render_template('layout.html')

# Initialize the database
with app.app_context():
    db.create_all()

if __name__ == '__main__':
    app.run(debug=True)


# @app.route("/delete_uploaded", methods=["POST"])
# def delete_uploaded():
#     try:
#         file_path = request.form.get("file_path")
#         if file_path and os.path.exists(file_path):
#             os.remove(file_path)
#             return render_template("upload.html", message="File deleted successfully")
#         else:
#             return render_template("upload.html", error="File not found")
#     except Exception as e:
#         return render_template("upload.html", error=f"Error deleting file: {str(e)}")

# @app.route("/serve_uploaded_file/<path:file_path>")
# def serve_uploaded_file(file_path):
#     full_path = os.path.join(UPLOAD_FOLDER, file_path)
#     if os.path.exists(full_path):
#         return send_file(full_path, as_attachment=False)  # Opens in browser if supported, or downloads
#     else:
#         return render_template("upload.html", error="File not found")
    

# for verify data when user submit the file xlsx
# @app.route("/verify")
# def verify():
#     return render_template("verifyResult.html")


@app.route("/upload", methods=["GET", "POST"], endpoint="upload")
def upload_file():
    if request.method == "POST":
        try:
            # Check if a file is uploaded
            if "file" not in request.files:
                return render_template("upload.html", error="No file uploaded")
            
            file = request.files["file"]
            
            # Check if the file is empty or not an .xlsx file
            if file.filename == "":
                return render_template("upload.html", error="No file selected")
            if not file.filename.lower().endswith(".xlsx"):
                return render_template("upload.html", error="Only .xlsx files are allowed!")
            
            # Generate a unique filename and save the file
            unique_filename = f"{uuid.uuid4().hex}_{file.filename}"
            upload_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(upload_path)
            
            # Read the uploaded Excel file
            df_uploaded = pd.read_excel(upload_path)
            
            # Get data from SQLite (only students table)
            with sqlite3.connect("database.db") as con:
                con.row_factory = sqlite3.Row
                cur = con.cursor()
                cur.execute("""
                    SELECT first_name, second_name, age, gender, email, 
                           school_name, addr, city
                    FROM students
                """)
                db_rows = cur.fetchall()
            
            # Convert SQLite data to DataFrame for easier comparison
            db_df = pd.DataFrame(db_rows, columns=[
                'First Name', 'Second Name', 'Age', 'Gender', 'Email', 
                'School Name', 'Address', 'City'
            ])
            
            # Prepare comparison results
            comparison_results = []
            
            # Define columns to compare (only those in students table)
            student_columns = [
                'First Name', 'Second Name', 'Age', 'Gender', 'Email',
                'School Name', 'Address', 'City'
            ]
            
            # Check if uploaded file has at least the student columns
            if not all(col in df_uploaded.columns for col in student_columns):
                return render_template("upload.html", 
                                     error="Uploaded file is missing required student columns")
            
            # Normalize dataframes (strip strings, handle NaN)
            for col in student_columns:
                if df_uploaded[col].dtype == 'object':
                    df_uploaded[col] = df_uploaded[col].astype(str).str.strip()
                if db_df[col].dtype == 'object':
                    db_df[col] = db_df[col].astype(str).str.strip()
            
            # Replace NaN with empty string for consistent comparison
            df_uploaded = df_uploaded.fillna('')
            db_df = db_df.fillna('')
            
            # Compare each row
            for index, uploaded_row in df_uploaded.iterrows():
                # Try to find matching record in database
                matching_rows = db_df[
                    (db_df['First Name'] == uploaded_row['First Name']) &
                    (db_df['Second Name'] == uploaded_row['Second Name'])
                ]
                
                # Include all columns from uploaded file in results, even if not compared
                row_data = {
                    'First Name': uploaded_row['First Name'],
                    'Second Name': uploaded_row['Second Name'],
                    'Age': uploaded_row['Age'],
                    'Gender': uploaded_row['Gender'],
                    'Email': uploaded_row['Email'],
                    'School Name': uploaded_row['School Name'],
                    'Address': uploaded_row['Address'],
                    'City': uploaded_row['City'],
                }
                
                # Add transaction columns if they exist in the uploaded file
                for col in ['SEL', 'Tran Date', 'Time', 'Code', 'Description']:
                    if col in df_uploaded.columns:
                        row_data[col] = uploaded_row[col]
                
                if not matching_rows.empty:
                    match_row = matching_rows.iloc[0]
                    is_match = True
                    # Compare only student-related columns
                    print(f"\nComparing row {index}:")
                    for col in student_columns:
                        upload_val = str(uploaded_row[col])
                        db_val = str(match_row[col])
                        if upload_val != db_val:
                            print(f"Mismatch in {col}: '{upload_val}' vs '{db_val}'")
                            is_match = False
                    row_data['Result'] = 'Pass' if is_match else 'Fail'
                else:
                    print(f"No match found for {uploaded_row['First Name']} {uploaded_row['Second Name']}")
                    row_data['Result'] = 'Fail'
                
                comparison_results.append(row_data)
            
            # Generate Excel file with results
            result_filename = f"verification_results_{uuid.uuid4().hex}.xlsx"
            result_path = os.path.join(UPLOAD_FOLDER, result_filename)
            result_df = pd.DataFrame(comparison_results)
            result_df.to_excel(result_path, index=False)
            
            # Clean up: remove the temporary uploaded file
            os.remove(upload_path)
            
            # Render the verification results with download link
            return render_template("verifyResult.html", 
                                results=comparison_results,
                                message="Verification completed",
                                download_file=result_filename)
        
        except Exception as e:
            return render_template("upload.html", 
                                error=f"Error processing file: {str(e)}")
    
    # For GET request, render the upload form
    return render_template("upload.html")

# New route to serve the generated Excel file
@app.route("/download/<filename>")
def download_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True)



============

import cv2
import torch

# Load YOLOv5 model (pre-trained, e.g., 'yolov5s' for small model)
model = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True)  # Use 'yolov5s', 'yolov5m', 'yolov5l', etc.

# Load the table image
table_image = cv2.imread("C:/Users/MSI/Documents/Thesis_Project/Automste_Testing_DeepSeek_Model/Fine-Tuning-Deep-Seek_R1/static/images/6b4ba075eb7040f2b0e60ea75b4a73c3.png")
if table_image is None:
    print("Error: Could not load the table image.")
    exit()

# Resize the table image for overlay
table_image_resized = cv2.resize(table_image, (400, 200))  # Adjust size as needed

# Set up webcam
cap = cv2.VideoCapture(0)
if not cap.isOpened():
    print("Error: Could not open webcam.")
    exit()

# Run YOLOv5 on the table image to detect objects
# YOLOv5 expects images in RGB format, so convert from BGR
img_rgb = cv2.cvtColor(table_image, cv2.COLOR_BGR2RGB)
results = model(img_rgb)  # Run inference
detections = results.xyxy[0]  # Get bounding boxes (x1, y1, x2, y2, conf, cls)
print(f"Number of detections: {len(detections)}")  # Debug: Check if YOLO detects anything

# Store detected objects with their labels
detected_objects = []
for detection in detections:
    x1, y1, x2, y2, conf, cls = detection  # YOLOv5 output: [x1, y1, x2, y2, confidence, class]
    x1, y1, x2, y2 = map(int, [x1, y1, x2, y2])  # Convert to integers
    conf = conf.item()  # Confidence score
    cls = int(cls.item())  # Class index
    label = model.names[cls]  # Get class name from YOLOv5 model
    print(f"Detection: {label} (confidence: {conf})")  # Debug: Check detected objects and confidence
    if conf > 0.3:  # Confidence threshold
        detected_objects.append((x1, y1, x2, y2, f"{label} ({conf:.2f})"))

# Scale the bounding box coordinates to the resized table image
scale_x = table_image_resized.shape[1] / table_image.shape[1]
scale_y = table_image_resized.shape[0] / table_image.shape[0]
scaled_detections = []
for x1, y1, x2, y2, label in detected_objects:
    x1, x2 = int(x1 * scale_x), int(x2 * scale_x)
    y1, y2 = int(y1 * scale_y), int(y2 * scale_y)
    scaled_detections.append((x1, y1, x2, y2, label))

while True:
    # Capture frame from webcam
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame.")
        break

    # Overlay the table image on the frame (top-left corner)
    h, w, _ = table_image_resized.shape
    frame_with_table = frame.copy()
    frame_with_table[0:h, 0:w] = table_image_resized

    # Draw bounding boxes and labels on the overlaid table image
    for x1, y1, x2, y2, label in scaled_detections:
        # Draw bounding box
        cv2.rectangle(frame_with_table, (x1, y1), (x2, y2), (0, 255, 0), 2)
        # Draw label above the box
        cv2.putText(frame_with_table, label, (x1, y1 - 10), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    # Display the frame
    cv2.imshow("Webcam with Table and YOLOv5 Detections", frame_with_table)

    # Exit on 'q' key press
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()



============
import easyocr
import cv2
import torch
import random

# Initialize EasyOCR reader
reader = easyocr.Reader(['en'])

# Initialize YOLOv5 model (Pre-trained)
model = torch.hub.load('ultralytics/yolov5', 'yolov5n')  # Use 'yolov5s' for small model or 'yolov5m'/'yolov5l' for larger models

# Read image
img = cv2.imread('test.png')

# Resize the image if it's too large
scale_percent = 70  # Adjust this scale as needed
width = int(img.shape[1] * scale_percent / 100)
height = int(img.shape[0] * scale_percent / 100)
img_resized = cv2.resize(img, (width, height))

# Perform YOLOv5 object detection
results = model(img_resized)

# Get the detected bounding boxes for text-related objects (class 'text' is often identified by YOLO)
# You can filter by class if your YOLOv5 model detects text objects
text_bboxes = results.xywh[0]  # Bounding boxes, classes, and confidence scores

# Check if YOLO detected anything
print(f"Number of detections: {len(text_bboxes)}")

# Draw YOLO detections (Object detection boxes)
for bbox in text_bboxes:
    x_center, y_center, w, h, conf, cls = bbox

    if conf > 0.5:  # Threshold for confidence; adjust as needed
        # Convert YOLO bounding box from center format to corner format
        x1 = int((x_center - w / 2))
        y1 = int((y_center - h / 2))
        x2 = int((x_center + w / 2))
        y2 = int((y_center + h / 2))
        
        # Generate a random color for the bounding box (RGB format)
        color = [random.randint(0, 255) for _ in range(3)]  # Random color for each object
        
        # Draw bounding box for detected object (YOLO)
        cv2.rectangle(img_resized, (x1, y1), (x2, y2), color, 2)  # Bounding box with random color
        label = f"Object {int(cls)}"  # Label as object
        cv2.putText(img_resized, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

# Perform text detection using EasyOCR (after YOLO detections)
ocr_results = reader.readtext(img_resized)

# Draw bounding boxes and labels for OCR text detection with different colors for each object
for idx, (bbox, text, prob) in enumerate(ocr_results):
    (x1_text, y1_text), (x2_text, y2_text), (x3_text, y3_text), (x4_text, y4_text) = bbox
    x1_text, y1_text, x3_text, y3_text = int(x1_text), int(y1_text), int(x3_text), int(y3_text)

    # Generate a random color for each OCR text bounding box
    color = [random.randint(0, 255) for _ in range(3)]  # Random color for each bounding box

    # Draw rectangle for OCR text bounding box (with random color)
    cv2.rectangle(img_resized, (x1_text - 10, y1_text - 10), (x3_text + 10, y3_text + 10), color, 2)  # Random color for OCR

    # Put text (the OCR result) inside the bounding box
    cv2.putText(img_resized, text, (x1_text, y1_text - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

# Resize window to fit screen
cv2.namedWindow('Image', cv2.WINDOW_NORMAL)  
cv2.imshow('Image', img_resized)
cv2.waitKey(0)
cv2.destroyAllWindows()


=====================
# import cv2
# import torch

# # Load YOLOv5 model (pre-trained on COCO dataset)
# model = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True)

# # Set up webcam
# cap = cv2.VideoCapture(0)  # Use 0 for the default webcam
# if not cap.isOpened():
#     print("Error: Could not open webcam.")
#     exit()

# while True:
#     # Capture frame from webcam
#     ret, frame = cap.read()
#     if not ret:
#         print("Error: Could not read frame.")
#         break

#     # Convert frame from BGR to RGB (YOLO expects RGB)
#     img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

#     # Run YOLOv5 inference
#     results = model(img_rgb)

#     # Extract bounding boxes, confidence scores, and class labels
#     detections = results.xyxy[0]  # Get detections

#     for detection in detections:
#         x1, y1, x2, y2, conf, cls = detection  # YOLOv5 output: [x1, y1, x2, y2, confidence, class]
#         x1, y1, x2, y2 = map(int, [x1, y1, x2, y2])  # Convert to integers
#         conf = conf.item()  # Confidence score
#         cls = int(cls.item())  # Class index
#         label = f"{model.names[cls]} ({conf:.2f})"  # Get class name and confidence

#         if conf > 0.3:  # Only draw boxes with confidence > 30%
#             # Draw bounding box
#             cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
#             # Draw label
#             cv2.putText(frame, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

#     # Display the frame with detections
#     cv2.imshow("YOLOv5 Live Object Detection", frame)

#     # Exit on 'q' key press
#     if cv2.waitKey(1) & 0xFF == ord('q'):
#         break

# # Release resources
# cap.release()
# cv2.destroyAllWindows()


# Import PyTorch module
# import torch
# import cv2

# # Download model from github
# model = torch.hub.load('ultralytics/yolov5', 'yolov5n')
    
# img = cv2.imread('test.png')
# img = cv2.resize(img,(1000, 650))

# # Perform detection on image
# result = model(img)
# print('result: ', result)

# # Convert detected result to pandas data frame
# data_frame = result.pandas().xyxy[0]
# print('data_frame:')
# print(data_frame)

# # Get indexes of all of the rows
# indexes = data_frame.index
# for index in indexes:
#     # Find the coordinate of top left corner of bounding box
#     x1 = int(data_frame['xmin'][index])
#     y1 = int(data_frame['ymin'][index])
#     # Find the coordinate of right bottom corner of bounding box
#     x2 = int(data_frame['xmax'][index])
#     y2 = int(data_frame['ymax'][index ])

#     # Find label name
#     label = data_frame['name'][index ]
#     # Find confidance score of the model
#     conf = data_frame['confidence'][index]
#     text = label + ' ' + str(conf.round(decimals= 2))

#     cv2.rectangle(img, (x1,y1), (x2,y2), (255,255,0), 2)
#     cv2.putText(img, text, (x1,y1-5), cv2.FONT_HERSHEY_PLAIN, 2,
#                 (255,255,0), 2)

# cv2.imshow('IMAGE', img)
# cv2.waitKey(0)

# import easyocr
# import cv2

# # Initialize EasyOCR reader
# reader = easyocr.Reader(['en'])

# # Read image
# img = cv2.imread('test.png')

# # Resize the image if it's too large
# scale_percent = 70  # Adjust this scale as needed
# width = int(img.shape[1] * scale_percent / 100)
# height = int(img.shape[0] * scale_percent / 100)
# img = cv2.resize(img, (width, height))

# # Perform text detection
# results = reader.readtext(img)

# # Draw bounding boxes around detected text with proper spacing
# for (bbox, text, prob) in results:
#     (x1, y1), (x2, y2), (x3, y3), (x4, y4) = bbox

#     # Convert coordinates to integers
#     x1, y1, x3, y3 = int(x1), int(y1), int(x3), int(y3)

#     # Draw rectangle with padding
#     cv2.rectangle(img, (x1 - 10, y1 - 10), (x3 + 10, y3 + 10), (255, 255, 0), 2)

#     # Calculate text size for spacing
#     text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.8, 2)[0]
#     text_height = text_size[1] + 10  # Extra spacing

#     # Adjust text position with spacing
#     text_y = max(y1 - 15, 20)  # Prevent text from going off-screen
#     for i, line in enumerate(text.split()):  # If multiple words, display them separately
#         line_y = text_y + (i * text_height)  # Space out each line
#         cv2.putText(img, line, (x1, line_y), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2)

# # Resize window to fit screen
# cv2.namedWindow('Image', cv2.WINDOW_NORMAL)  
# cv2.imshow('Image', img)
# cv2.waitKey(0)
# cv2.destroyAllWindows()

==============
import easyocr
import cv2
import torch
import random
import numpy as np

# Initialize EasyOCR reader
reader = easyocr.Reader(['en'])

# Initialize YOLOv5 model (Pre-trained)
model = torch.hub.load('ultralytics/yolov5', 'yolov5n')  # Use 'yolov5s' for small model or 'yolov5m'/'yolov5l' for larger models

# Read image
img = cv2.imread('image_test_case.png')

# Resize the image if it's too large
scale_percent = 70  # Adjust this scale as needed
width = int(img.shape[1] * scale_percent / 100)
height = int(img.shape[0] * scale_percent / 100)
img_resized = cv2.resize(img, (width, height))

# Perform YOLOv5 object detection
results = model(img_resized)

# Get the detected bounding boxes for text-related objects
text_bboxes = results.xywh[0]  # Bounding boxes, classes, and confidence scores

# Check if YOLO detected anything
print(f"Number of detections: {len(text_bboxes)}")

# Draw YOLO detections (Object detection boxes)
for bbox in text_bboxes:
    x_center, y_center, w, h, conf, cls = bbox

    if conf > 0.5:  # Threshold for confidence; adjust as needed
        # Convert YOLO bounding box from center format to corner format
        x1 = int((x_center - w / 2))
        y1 = int((y_center - h / 2))
        x2 = int((x_center + w / 2))
        y2 = int((y_center + h / 2))
        
        # Generate a random color for the bounding box (RGB format)
        color = [random.randint(0, 255) for _ in range(3)]  # Random color for each object
        
        # Draw bounding box for detected object (YOLO)
        cv2.rectangle(img_resized, (x1, y1), (x2, y2), color, 2)  # Bounding box with random color
        label = f"Object {int(cls)}"  # Label as object
        cv2.putText(img_resized, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

# Perform text detection using EasyOCR
ocr_results = reader.readtext(img_resized)

# List of custom labels for each column
custom_labels = ['First Name', 'Second Name', 'Age', 'Gender', 'Email', 'School Name', 'Address', 'City', 'Result']

# Helper functions to get y-center, x-start, and x-end of a bounding box
def get_y_center(bbox):
    (x1, y1), (x2, y2), (x3, y3), (x4, y4) = bbox
    return (y1 + y3) / 2

def get_x_start(bbox):
    (x1, y1), (x2, y2), (x3, y3), (x4, y4) = bbox
    return x1

def get_x_end(bbox):
    (x1, y1), (x2, y2), (x3, y3), (x4, y4) = bbox
    return x3

# Step 1: Sort OCR results by y-coordinate (to group by rows) and then by x-coordinate (to order within rows)
ocr_results_sorted = sorted(ocr_results, key=lambda x: (get_y_center(x[0]), get_x_start(x[0])))

# Step 2: Group OCR results into rows based on y-coordinates
rows = []
current_row = []
last_y = None
y_threshold = 50  # Increased to better group text within the same row

for result in ocr_results_sorted:
    bbox, text, prob = result
    y_center = get_y_center(bbox)
    
    if last_y is None or abs(y_center - last_y) < y_threshold:
        current_row.append(result)
    else:
        rows.append(current_row)
        current_row = [result]
    last_y = y_center

# Add the last row
if current_row:
    rows.append(current_row)

# Debug: Print the number of rows
print(f"Total rows detected: {len(rows)}")

# Step 3: Skip the header row (first row) and process data rows
data_rows = rows[1:]  # Skip the first row (header)

# Step 4: Estimate column boundaries from the header row
header_row = rows[0]  # First row is the header
header_items = sorted(header_row, key=lambda x: get_x_start(x[0]))
column_boundaries = []
for idx, (bbox, text, prob) in enumerate(header_items):
    x_start = get_x_start(bbox)
    x_end = get_x_end(bbox)
    print(f"Header {text}: x_start={x_start}, x_end={x_end}")
    if idx == 0:
        column_boundaries.append(x_start)
    if idx == len(header_items) - 1:
        column_boundaries.append(x_end)
    else:
        next_x_start = get_x_start(header_items[idx + 1][0])
        boundary = (x_end + next_x_start) / 2
        column_boundaries.append(boundary)

# Debug: Print column boundaries
print("Column boundaries:", column_boundaries)

# Adjust column boundaries manually based on the raw text detections
# Using the x-centers from Row 1:
# Sophea: 83.0 (First Name)
# Oudom: 266.0 (Second Name)
# 21: 420.0 (Age)
# Male: 621.0 (Gender)
# dom@gmail.c: 861.0, om: 794.0 (Email, should be merged)
# Rupp: 993.5 (School Name)
# St.99 Hm2o: 1219.0 (Address)
# PPenh: 1375.0 (City)
# Pass: 1546.0 (Result)
adjusted_boundaries = [30, 200, 350, 500, 700, 900, 1100, 1300, 1500, 1600]
print("Adjusted column boundaries:", adjusted_boundaries)

# Step 5: Merge split text detections within each row using column boundaries
def merge_split_text(row, column_boundaries):
    # Sort the row by x-coordinate
    row_sorted = sorted(row, key=lambda x: get_x_start(x[0]))

    # Debug: Print the raw text detections in the row
    print("Raw text detections in row:")
    for bbox, text, prob in row_sorted:
        x_center = (get_x_start(bbox) + get_x_end(bbox)) / 2
        print(f"  Text: {text}, x_center: {x_center}")

    # Assign each text item to a column based on its x-coordinate
    column_items = [[] for _ in range(len(custom_labels))]
    for bbox, text, prob in row_sorted:
        x_center = (get_x_start(bbox) + get_x_end(bbox)) / 2
        # Find the column this text belongs to
        for col_idx in range(len(column_boundaries) - 1):
            if column_boundaries[col_idx] <= x_center < column_boundaries[col_idx + 1]:
                column_items[col_idx].append((bbox, text, prob))
                break

    # Merge text within each column with improved splitting logic
    merged_row = []
    for col_idx, items in enumerate(column_items):
        if not items:
            # If the column is empty, add a placeholder
            merged_row.append(([(0, 0), (0, 0), (0, 0), (0, 0)], "", 0.0))
        else:
            # Merge all items in this column
            combined_text = " ".join(item[1] for item in items)
            # Use the bounding box of the first item (or combine them)
            bbox = items[0][0]
            prob = max(item[2] for item in items)
            if len(items) > 1:
                # Combine bounding boxes
                (x1, y1), (x2, y2), (x3, y3), (x4, y4) = bbox
                for other_bbox, _, _ in items[1:]:
                    (nx1, ny1), (nx2, ny2), (nx3, ny3), (nx4, ny4) = other_bbox
                    x1 = min(x1, nx1)
                    y1 = min(y1, ny1)
                    x2 = max(x2, nx2)
                    y2 = max(y2, ny2)
                    x3 = max(x3, nx3)
                    y3 = max(y3, ny3)
                    x4 = min(x4, nx4)
                    y4 = min(y4, ny4)
                bbox = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]

            # Post-process the combined text based on the column
            if col_idx == 4:  # Email column
                # Remove spaces in email addresses
                combined_text = combined_text.replace(" ", "")
            merged_row.append((bbox, combined_text, prob))

    # Ensure the row has the correct number of columns
    while len(merged_row) < len(custom_labels):
        merged_row.append(([(0, 0), (0, 0), (0, 0), (0, 0)], "", 0.0))

    # Post-process to fix column misalignment
    # Step 1: Fix "Second Name" and "Age"
    if merged_row[1][1]:  # If Second Name column has text
        parts = merged_row[1][1].split()
        if len(parts) > 1 and parts[-1].isdigit():
            merged_row[1] = (merged_row[1][0], " ".join(parts[:-1]), merged_row[1][2])  # Second Name
            merged_row[2] = (merged_row[2][0], parts[-1], merged_row[2][2])  # Age

    # Step 2: Split "Address", "City", and "Result" correctly
    if merged_row[6][1]:  # If Address column has text
        parts = merged_row[6][1].split()
        if len(parts) >= 3:  # Expecting something like "St.99 Hm2o PPenh Pass"
            # Last part should be "Pass" or "Fail"
            if parts[-1] in ["Pass", "Fail"]:
                merged_row[8] = (merged_row[8][0], parts[-1], merged_row[8][2])  # Result
                # Second-to-last part should be the city (e.g., "PPenh")
                merged_row[7] = (merged_row[7][0], parts[-2], merged_row[7][2])  # City
                # The rest is the address
                merged_row[6] = (merged_row[6][0], " ".join(parts[:-2]), merged_row[6][2])  # Address

    return merged_row[:len(custom_labels)]  # Ensure the row matches the number of columns

# Step 6: Process each row, merge split text, and assign labels
for row_idx, row in enumerate(data_rows):
    # Merge split text within the row using adjusted column boundaries
    merged_row = merge_split_text(row, adjusted_boundaries)
    
    # Debug: Print the merged row to verify the text
    print(f"Row {row_idx + 1}:")
    for idx, (bbox, text, prob) in enumerate(merged_row):
        # Ensure email has no spaces
        if idx == 4:
            text = text.replace(" ", "")
            merged_row[idx] = (bbox, text, prob)
        print(f"  Column {idx + 1} ({custom_labels[idx]}): {text}")

    # Assign labels to each column in the row
    for idx, (bbox, text, prob) in enumerate(merged_row):
        if text == "":
            continue  # Skip empty items (from padding)

        (x1_text, y1_text), (x2_text, y2_text), (x3_text, y3_text), (x4_text, y4_text) = bbox
        x1_text, y1_text, x3_text, y3_text = int(x1_text), int(y1_text), int(x3_text), int(y3_text)

        # Generate a random color for each OCR text bounding box
        color = [random.randint(0, 255) for _ in range(3)]  # Random color for each bounding box

        # Assign the custom label based on the column index
        label = custom_labels[idx] if idx < len(custom_labels) else "Text"
        cv2.rectangle(img_resized, (x1_text - 10, y1_text - 10), (x3_text + 10, y3_text + 10), color, 2)
        cv2.putText(img_resized, label, (x1_text, y1_text - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)

# Resize window to fit screen
cv2.namedWindow('Image', cv2.WINDOW_NORMAL)  
cv2.imshow('Image', img_resized)
cv2.waitKey(0)
cv2.destroyAllWindows()



==================
webcam.Py

# import easyocr
# import cv2
# import torch
# import random
# import numpy as np
# from collections import defaultdict

# # Initialize EasyOCR reader
# reader = easyocr.Reader(['en'])

# # Initialize YOLOv5 model
# model = torch.hub.load('ultralytics/yolov5', 'yolov5s')
# model.conf = 0.3
# model.iou = 0.4

# # Read and resize image
# img = cv2.imread('image_test_case.png')
# scale_percent = 70
# width = int(img.shape[1] * scale_percent / 100)
# height = int(img.shape[0] * scale_percent / 100)
# img_resized = cv2.resize(img, (width, height))

# # YOLO Detection
# results = model(img_resized)
# detections = results.pandas().xyxy[0]

# for _, det in detections.iterrows():
#     if det['confidence'] > 0.25:
#         x1, y1, x2, y2 = int(det['xmin']), int(det['ymin']), int(det['xmax']), int(det['ymax'])
#         color = (random.randint(100, 255), random.randint(100, 255), random.randint(100, 255))
#         cv2.rectangle(img_resized, (x1, y1), (x2, y2), color, 2)
#         cv2.putText(img_resized, f"{det['name']} {det['confidence']:.2f}",
#                     (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

# # EasyOCR Processing
# ocr_results = reader.readtext(img_resized, paragraph=False, detail=1, batch_size=10, width_ths=0.4)
# custom_labels = ['First Name', 'Second Name', 'Age', 'Gender', 'Email',
#                  'School Name', 'Address', 'City', 'Result']

# def get_y_center(bbox):
#     return (bbox[0][1] + bbox[2][1]) / 2

# def get_x_center(bbox):
#     return (bbox[0][0] + bbox[2][0]) / 2

# rows = defaultdict(list)
# for bbox, text, prob in ocr_results:
#     y_center = get_y_center(bbox)
#     rows[round(y_center / 10) * 10].append((bbox, text.strip(), prob))

# sorted_rows = sorted(rows.items(), key=lambda x: x[0])

# for row_idx, (y_pos, row_items) in enumerate(sorted_rows):
#     row_items.sort(key=lambda x: get_x_center(x[0]))
#     print(f"\nRow {row_idx + 1}:")
    
#     row_texts = [text for _, text, _ in row_items]
    
#     if row_idx == 0:  # Ensure proper header alignment
#         row_texts = custom_labels[:len(row_texts)]
    
#     if len(row_texts) == len(custom_labels):
#         for col_idx, text in enumerate(row_texts):
#             print(f"  {custom_labels[col_idx]}: {text}")
#     elif len(row_texts) >= 2:  # Avoid rows with too little data
#         for col_idx, text in enumerate(row_texts):
#             label = custom_labels[min(col_idx, len(custom_labels)-1)]
#             print(f"  {label}: {text}")
            
#     # Draw bounding boxes for OCR detected text
#     for bbox, text, _ in row_items:
#         color = (0, 255, 0)  # Green for all detected text
#         cv2.rectangle(img_resized, tuple(map(int, bbox[0])), tuple(map(int, bbox[2])), color, 2)
#         cv2.putText(img_resized, text,
#                     (int(bbox[0][0]), int(bbox[0][1]-5)),
#                     cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
    
# cv2.imshow('Combined Detection', img_resized)
# cv2.waitKey(0)
# cv2.destroyAllWindows()

===============
================
from flask import Flask, render_template, request, send_file, send_from_directory, jsonify
import sqlite3
import pandas as pd
from datetime import datetime
from openpyxl import Workbook
import openpyxl
from flask_cors import CORS
import os
import random
import uuid
import string
import re

app = Flask(__name__)
CORS(app)

# Register the basename filter
from os.path import basename
app.jinja_env.filters['basename'] = basename

# Ensure an 'uploads' directory exists
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# Ensure 'static/images' directory exists
STATIC_IMAGES_FOLDER = os.path.join('static', 'images')
if not os.path.exists(STATIC_IMAGES_FOLDER):
    os.makedirs(STATIC_IMAGES_FOLDER)

# Initialize the database (create table if it doesnâ€™t exist)
def init_db():
    with sqlite3.connect('database.db') as con:
        cur = con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS students (
                first_name TEXT,
                second_name TEXT,
                age INTEGER,
                gender TEXT,
                email TEXT,
                school_name TEXT,
                addr TEXT,
                city TEXT
            )
        """)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS transactions (
                policy_id TEXT,
                sel TEXT,
                tran_date TEXT,
                time TEXT,
                code TEXT,
                description TEXT,
                loc TEXT
            )
        """)
        con.commit()

# Call this once to set up the database
init_db()

# Home Page route
@app.route("/")
def home():
    return render_template("home.html")

# Route to form used to add a new student to the database
@app.route("/enternew")
def enternew():
    return render_template("student.html")

@app.route("/addrec", methods=['POST', 'GET'])
def addrec():
    if request.method == 'POST':
        try:
            # Get data from the form
            first_name = request.form['first_name']
            second_name = request.form['second_name']
            age = request.form['age']
            gender = request.form['gender']
            email = request.form['email']
            school_name = request.form['school_name']
            addr = request.form['add']
            city = request.form['city']

            # Validation code (unchanged)
            def has_special_characters(text):
                pattern = r'^[a-zA-Z0-9\s.,-]+$'
                return not bool(re.match(pattern, text))

            fields_to_check = {
                'First Name': first_name,
                'Second Name': second_name,
                'School Name': school_name,
                'Address': addr,
                'City': city
            }
            for field_name, value in fields_to_check.items():
                if has_special_characters(value):
                    msg = f"No special characters allowed in {field_name}"
                    return render_template('result.html', data={"error": msg})

            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, email):
                return render_template('result.html', data={"error": "Invalid email format"})

            # Insert into database (unchanged)
            with sqlite3.connect('database.db') as con:
                cur = con.cursor()
                cur.execute("""
                    INSERT INTO students 
                    (first_name, second_name, age, gender, email, school_name, addr, city) 
                    VALUES (?,?,?,?,?,?,?,?)
                """, (first_name, second_name, age, gender, email, school_name, addr, city))
                policy_id = cur.lastrowid
                policy_id_str = f"POL{policy_id:05d}"

                submission_date = datetime.now().strftime("%d/%m/%Y")
                submission_time = datetime.now().strftime("%H:%M:%S")
                
                def generate_random_sel():
                    return f"{random.randint(10000, 99999):05d}"

                def generate_random_code():
                    return f"B{random.randint(100, 999)}"
                
                transactions = [
                    {
                        "sel": generate_random_sel(),
                        "tran_date": submission_date,
                        "time": submission_time,
                        "code": generate_random_code(),
                        "description": f"Student Registration - {first_name} {second_name}",
                        "loc": "P"
                    },
                    {
                        "sel": generate_random_sel(),
                        "tran_date": submission_date,
                        "time": submission_time,
                        "code": generate_random_code(),
                        "description": f"School Name - {school_name}",
                        "loc": "P"
                    }
                ]
                for tran in transactions:
                    cur.execute("""
                        INSERT INTO transactions (policy_id, sel, tran_date, time, code, description, loc)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                    """, (policy_id_str, tran["sel"], tran["tran_date"], tran["time"], tran["code"], tran["description"], tran["loc"]))
                con.commit()

            # Update students.xlsx with only one row per student
            file_path = os.path.join(app.static_folder, 'students.xlsx')
            if not os.path.exists(file_path):
                wb = Workbook()
                ws = wb.active
                ws.append(['First Name', 'Second Name', 'Age', 'Gender', 'Email', 'School Name', 'Address', 'City', 
                           'SEL', 'Tran Date', 'Time', 'Code', 'Description', 'Loc'])
            else:
                wb = openpyxl.load_workbook(file_path)
                ws = wb.active

            # Write only one row, using the first transaction's data and school_name as description
            tran = transactions[0]  # Use the first transaction
            ws.append([first_name, second_name, age, gender, email, school_name, addr, city,
                       tran["sel"], tran["tran_date"], tran["time"], tran["code"], school_name, tran["loc"]])
            wb.save(file_path)

            detail_data = [
                {
                    "first_name": first_name,
                    "second_name": second_name,
                    "age": age,
                    "gender": gender,
                    "email": email,
                    "school_name": school_name,
                    "addr": addr,
                    "city": city,
                    "sel": transactions[0]["sel"],
                    "tran_date": transactions[0]["tran_date"],
                    "time": transactions[0]["time"],
                    "code": transactions[0]["code"],
                    "description": transactions[0]["description"],
                    "loc": transactions[0]["loc"]
                }
            ]

            data = {
                "policy_id": policy_id_str,
                "first_name": first_name,
                "second_name": second_name,
                "city": city,
                "transactions": transactions,
                "detail_data": detail_data
            }
            return render_template('result.html', data=data)

        except Exception as e:
            if 'con' in locals():
                con.rollback()
            msg = f"Error in the INSERT: {str(e)}"
            return render_template('result.html', data={"error": msg})
        finally:
            if 'con' in locals():
                con.close()

@app.route("/run", methods=['POST'])
def run():
    try:
        rowid = request.form['id']
        with sqlite3.connect("database.db") as con:
            con.row_factory = sqlite3.Row
            cur = con.cursor()
            cur.execute("SELECT * FROM students WHERE rowid = ?", (rowid,))
            student = cur.fetchone()
            if not student:
                return render_template('result.html', data={"error": "Student not found"})

            policy_id = f"POL{int(rowid):05d}"
            cur.execute("SELECT sel, tran_date, time, code, description, loc FROM transactions WHERE policy_id = ?", (policy_id,))
            transactions = [{"sel": row[0], "tran_date": row[1], "time": row[2], "code": row[3], "description": row[4], "loc": row[5]} for row in cur.fetchall()]
            if not transactions:
                transactions = []

            detail_data = [
                {
                    "first_name": student["first_name"],
                    "second_name": student["second_name"],
                    "age": student["age"],
                    "gender": student["gender"],
                    "email": student["email"],
                    "school_name": student["school_name"],
                    "addr": student["addr"],
                    "city": student["city"],
                    "sel": transactions[0]["sel"],
                    "tran_date": transactions[0]["tran_date"],
                    "time": transactions[0]["time"],
                    "code": transactions[0]["code"],
                    "description": transactions[0]["description"],
                    "loc": transactions[0]["loc"]
                }
            ] if transactions else []

        data = {
            "policy_id": policy_id,
            "first_name": student["first_name"],
            "second_name": student["second_name"],
            "city": student["city"],
            "transactions": transactions,
            "detail_data": detail_data
        }
        return render_template('result.html', data=data)

    except Exception as e:
        return render_template('result.html', data={"error": f"Error in RUN: {str(e)}"})

@app.route('/student_list')
def student_list():
    con = sqlite3.connect("database.db")
    con.row_factory = sqlite3.Row
    cur = con.cursor()
    cur.execute("SELECT rowid, * FROM students")
    rows = cur.fetchall()
    con.close()
    return render_template("list.html", rows=rows)

@app.route("/edit", methods=['POST', 'GET'])
def edit():
    if request.method == 'POST':
        try:
            id = request.form['id']
            con = sqlite3.connect("database.db")
            con.row_factory = sqlite3.Row
            cur = con.cursor()
            cur.execute("SELECT rowid, * FROM students WHERE rowid = ?", (id,))
            rows = cur.fetchall()
        except:
            rows = []
        finally:
            con.close()
            return render_template("edit.html", rows=rows)

@app.route("/editrec", methods=['POST', 'GET'])
def editrec():
    if request.method == 'POST':
        try:
            rowid = request.form['rowid']
            first_name = request.form['first_name']
            second_name = request.form['second_name']
            age = request.form['age']
            gender = request.form['gender']
            email = request.form['email']
            school_name = request.form['school_name']
            addr = request.form['add']
            city = request.form['city']

            # Update the database
            with sqlite3.connect('database.db') as con:
                cur = con.cursor()
                cur.execute("""
                    UPDATE students 
                    SET first_name = ?, second_name = ?, age = ?, gender = ?, email = ?, 
                        school_name = ?, addr = ?, city = ?
                    WHERE rowid = ?
                """, (first_name, second_name, age, gender, email, school_name, addr, city, rowid))
                policy_id = f"POL{int(rowid):05d}"
                # Fetch existing transactions for this student
                cur.execute("SELECT sel, tran_date, time, code, description, loc FROM transactions WHERE policy_id = ?", (policy_id,))
                transactions = [{"sel": row[0], "tran_date": row[1], "time": row[2], "code": row[3], "description": row[4], "loc": row[5]} for row in cur.fetchall()]
                con.commit()

            # Update students.xlsx with only one row per student
            file_path = os.path.join(app.static_folder, 'students.xlsx')
            wb = openpyxl.load_workbook(file_path)
            ws = wb.active

            # Remove old rows for this student (match by name as a simple approach)
            rows_to_keep = []
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row[0] != first_name or row[1] != second_name:
                    rows_to_keep.append(row)

            # Rewrite the Excel file
            ws.delete_rows(1, ws.max_row)  # Clear all rows
            ws.append(['First Name', 'Second Name', 'Age', 'Gender', 'Email', 'School Name', 'Address', 'City', 
                       'SEL', 'Tran Date', 'Time', 'Code', 'Description', 'Loc'])
            for row in rows_to_keep:
                ws.append(row)

            # Add updated student data with one row, using the first transaction
            tran = transactions[0]  # Use the first transaction
            ws.append([first_name, second_name, age, gender, email, school_name, addr, city,
                       tran["sel"], tran["tran_date"], tran["time"], tran["code"], school_name, tran["loc"]])
            wb.save(file_path)

            msg = "Record successfully edited in the database and Excel file"
            data = {"message": msg}

        except Exception as e:
            if 'con' in locals():
                con.rollback()
            msg = f"Error in the Edit: {str(e)}"
            data = {"error": msg}
        finally:
            if 'con' in locals():
                con.close()
            return render_template('result.html', data=data)

@app.route("/delete", methods=['POST', 'GET'])
def delete():
    if request.method == 'POST':
        try:
            rowid = request.form['id']
            policy_id = f"POL{int(rowid):05d}"
            file_path = os.path.join(app.static_folder, 'students.xlsx')

            # Delete from database
            with sqlite3.connect('database.db') as con:
                cur = con.cursor()
                cur.execute("DELETE FROM students WHERE rowid=?", (rowid,))
                cur.execute("DELETE FROM transactions WHERE policy_id=?", (policy_id,))
                con.commit()

                # Fetch remaining students and their transactions
                cur.execute("SELECT first_name, second_name, age, gender, email, school_name, addr, city, rowid FROM students")
                students = cur.fetchall()

            # Rewrite students.xlsx with one row per student
            wb = Workbook()
            ws = wb.active
            ws.append(['First Name', 'Second Name', 'Age', 'Gender', 'Email', 'School Name', 'Address', 'City', 
                       'SEL', 'Tran Date', 'Time', 'Code', 'Description', 'Loc'])

            for student in students:
                first_name, second_name, age, gender, email, school_name, addr, city, student_rowid = student
                student_policy_id = f"POL{student_rowid:05d}"
                cur.execute("SELECT sel, tran_date, time, code, description, loc FROM transactions WHERE policy_id = ?", (student_policy_id,))
                transactions = cur.fetchall()
                tran = transactions[0]  # Use the first transaction
                ws.append([first_name, second_name, age, gender, email, school_name, addr, city,
                           tran[0], tran[1], tran[2], tran[3], school_name, tran[5]])  # Use school_name as description

            wb.save(file_path)

            data = {"message": "Record successfully deleted from the database and Excel file"}
        except Exception as e:
            if 'con' in locals():
                con.rollback()
            data = {"error": f"Error in the DELETE: {str(e)}"}
        finally:
            if 'con' in locals():
                con.close()
            return render_template('result.html', data=data)


# when user upload file and click on submit so it go to displayverify.html file
from PIL import Image, ImageDraw, ImageFont
import os
import uuid
import textwrap

from PIL import Image, ImageDraw, ImageFont
import os
import uuid

def create_image_from_results(results):
    # Adjusted parameters to match the image
    font_size = 20  # Reduced font size for a closer match
    row_padding = 50  # Tighter vertical spacing between rows
    header_padding = 60  # Reduced space between header and first row
    col_spacing = 60  # Slightly reduced horizontal spacing between columns
    margin_left = 20  # Reduced left margin
    margin_top = 20  # Reduced top margin

    try:
        font = ImageFont.truetype("arial.ttf", font_size)
    except IOError:
        font = ImageFont.load_default()

    dummy_img = Image.new("RGB", (1, 1))
    draw = ImageDraw.Draw(dummy_img)

    headers = list(results[0].keys())
    num_rows = len(results)

    # Calculate column widths
    col_widths = []
    for header in headers:
        max_width = draw.textbbox((0, 0), header, font=font)[2]
        for row in results:
            value = str(row[header])
            text_width = draw.textbbox((0, 0), value, font=font)[2]
            max_width = max(max_width, text_width)
        col_widths.append(max_width + 10)  # Reduced padding per column

    # Calculate total width and height
    total_width = sum(col_widths) + (len(headers) - 1) * col_spacing + 2 * margin_left
    row_height = int(font_size * 1.5)  # Adjusted row height for tighter spacing
    estimated_height = margin_top + header_padding + (row_height + row_padding) * num_rows + 20  # Reduced extra padding

    img = Image.new("RGB", (total_width, estimated_height), color="white")
    draw = ImageDraw.Draw(img)

    # Draw headers
    x_offset = margin_left
    y_offset = margin_top
    for i, header in enumerate(headers):
        draw.text((x_offset, y_offset), header, font=font, fill="black")
        x_offset += col_widths[i] + col_spacing
    y_offset += header_padding

    # Draw rows
    for row in results:
        x_offset = margin_left
        for i, header in enumerate(headers):
            text = str(row[header])
            draw.text((x_offset, y_offset), text, font=font, fill="black")
            x_offset += col_widths[i] + col_spacing
        y_offset += row_height + row_padding

    # Create folder if not exists
    output_folder = "static/images"
    os.makedirs(output_folder, exist_ok=True)

    image_path = os.path.join(output_folder, f"{uuid.uuid4().hex}.png")
    img.save(image_path)

    return image_path


@app.route("/upload", methods=["GET", "POST"], endpoint="upload")
def upload_file():
    if request.method == "POST":
        try:
            if "file" not in request.files:
                return render_template("upload.html", error="No file uploaded")
            
            file = request.files["file"]
            if file.filename == "":
                return render_template("upload.html", error="No file selected")
            if not file.filename.lower().endswith(".xlsx"):
                return render_template("upload.html", error="Only .xlsx files are allowed!")
            
            # Save the uploaded file
            unique_filename = f"{uuid.uuid4().hex}_{file.filename}"
            upload_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(upload_path)
            
            # Process the file
            df_uploaded = pd.read_excel(upload_path)
            
            # Fetch data from the database
            with sqlite3.connect("database.db") as con:
                con.row_factory = sqlite3.Row
                cur = con.cursor()
                cur.execute("""SELECT first_name, second_name, age, gender, email, 
                               school_name, addr, city FROM students""")
                db_rows = cur.fetchall()
            
            db_df = pd.DataFrame(db_rows, columns=[
                'First Name', 'Second Name', 'Age', 'Gender', 'Email',
                'School Name', 'Address', 'City'
            ])
            
            # Prepare comparison results
            comparison_results = []
            student_columns = ['First Name', 'Second Name', 'Age', 'Gender', 'Email', 'School Name', 'Address', 'City']
            
            # Compare the data
            for index, uploaded_row in df_uploaded.iterrows():
                matching_rows = db_df[
                    (db_df['First Name'] == uploaded_row['First Name']) &
                    (db_df['Second Name'] == uploaded_row['Second Name'])
                ]
                
                row_data = {col: uploaded_row[col] for col in student_columns}
                
                if not matching_rows.empty:
                    match_row = matching_rows.iloc[0]
                    is_match = True
                    for col in student_columns:
                        if str(uploaded_row[col]) != str(match_row[col]):
                            is_match = False
                    row_data['Result'] = 'Pass' if is_match else 'Fail'
                else:
                    row_data['Result'] = 'Fail'
                
                comparison_results.append(row_data)
            
            # Generate image from results
            image_path = create_image_from_results(comparison_results)
            
            # Clean up: remove the temporary uploaded file
            os.remove(upload_path)
            
            return render_template("verifyResult.html", 
                                   results=comparison_results,
                                   message="Verification completed",
                                   image_path=image_path)
        
        except Exception as e:
            return render_template("upload.html", error=f"Error processing file: {str(e)}")
    
    return render_template("upload.html")


# New route to serve the generated Excel file
@app.route("/download/<filename>")
def download_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True)


# for route Result
@app.route("/displayResult")
def displayResult():
    return render_template("displayResult.html")

if __name__ == "__main__":
    app.run(debug=True)
