from flask import Flask, render_template, request
from flask_sqlalchemy import SQLAlchemy
from flask_restx import Api, Resource, fields, Namespace

# Initialize Flask app
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize SQLAlchemy
db = SQLAlchemy(app)

# Initialize Flask-RESTX API
api = Api(app, version='1.0', title='My API', description='A simple API', doc='/swagger/')

# Define the User model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    age = db.Column(db.Integer, nullable=False)
    genre = db.Column(db.String(50), nullable=False)
    dob = db.Column(db.String(50), nullable=False)
    personality = db.Column(db.String(100), nullable=False)
    job = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(500), nullable=False)

    def __init__(self, name, age, genre, dob, personality, job, description):
        self.name = name
        self.age = age
        self.genre = genre
        self.dob = dob
        self.personality = personality
        self.job = job
        self.description = description

# Create a namespace for User Information
user_ns = Namespace('User_Information', description='Operations related to user information')
api.add_namespace(user_ns)

# Define the user model for Swagger UI input validation
user_input_model = user_ns.model('User', {
    'name': fields.String(required=True, description='Name of the user'),
    'age': fields.Integer(required=True, description='Age of the user'),
    'genre': fields.String(required=True, description='Genre of the user'),
    'dob': fields.String(required=True, description='Date of birth'),
    'personality': fields.String(required=True, description='Personality description'),
    'job': fields.String(required=True, description='Job description'),
    'description': fields.String(required=True, description='Short description of the user')
})

# User Resource for POST (create user)
@user_ns.route('/user')
class UserResource(Resource):
    @user_ns.expect(user_input_model)
    @user_ns.doc('create_user')
    def post(self):
        """Create new user information"""
        data = request.get_json()
        
        # Check if user with the same name already exists
        if User.query.filter_by(name=data['name']).first():
            return {'message': f'User with name {data["name"]} already exists'}, 400
        
        # Create and save the new user
        user = User(
            name=data['name'],
            age=data['age'],
            genre=data['genre'],
            dob=data['dob'],
            personality=data['personality'],
            job=data['job'],
            description=data['description']
        )
        db.session.add(user)
        db.session.commit()
        
        return {'message': f'User {user.name} created successfully'}, 201

# User Resource by ID for GET, PUT, DELETE
@user_ns.route('/user/<int:user_id>')
class UserResourceById(Resource):
    def get(self, user_id):
        """Retrieve user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        return {
            'id': user.id,
            'name': user.name,
            'age': user.age,
            'genre': user.genre,
            'dob': user.dob,
            'personality': user.personality,
            'job': user.job,
            'description': user.description
        }, 200

    @user_ns.expect(user_input_model)
    def put(self, user_id):
        """Update existing user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        data = request.get_json()
        user.name = data['name']
        user.age = data['age']
        user.genre = data['genre']
        user.dob = data['dob']
        user.personality = data['personality']
        user.job = data['job']
        user.description = data['description']
        db.session.commit()
        return {'message': f'User {user_id} updated successfully'}, 200

    def delete(self, user_id):
        """Delete user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        db.session.delete(user)
        db.session.commit()
        return {'message': f'User {user_id} deleted successfully'}, 200

# User List Resource for GET (all users)
@user_ns.route('/users')
class UserList(Resource):
    def get(self):
        """Retrieve all user information"""
        users = User.query.all()
        if not users:
            return {'message': 'No users found', 'code': 404}, 404

        users_list = []
        for user in users:
            users_list.append({
                'id': user.id,
                'name': user.name,
                'age': user.age,
                'genre': user.genre,
                'dob': user.dob,
                'personality': user.personality,
                'job': user.job,
                'description': user.description
            })
        
        response = {
            'message': 'All user information retrieved successfully',
            'code': 200,
            'data': users_list
        }
        return response, 200

# Dashboard route
@app.route('/dashboard')
def dashboard():
    return render_template('layout.html')

# Initialize the database
with app.app_context():
    db.create_all()

if __name__ == '__main__':
    app.run(debug=True)


# @app.route("/delete_uploaded", methods=["POST"])
# def delete_uploaded():
#     try:
#         file_path = request.form.get("file_path")
#         if file_path and os.path.exists(file_path):
#             os.remove(file_path)
#             return render_template("upload.html", message="File deleted successfully")
#         else:
#             return render_template("upload.html", error="File not found")
#     except Exception as e:
#         return render_template("upload.html", error=f"Error deleting file: {str(e)}")

# @app.route("/serve_uploaded_file/<path:file_path>")
# def serve_uploaded_file(file_path):
#     full_path = os.path.join(UPLOAD_FOLDER, file_path)
#     if os.path.exists(full_path):
#         return send_file(full_path, as_attachment=False)  # Opens in browser if supported, or downloads
#     else:
#         return render_template("upload.html", error="File not found")
    

# for verify data when user submit the file xlsx
# @app.route("/verify")
# def verify():
#     return render_template("verifyResult.html")


@app.route("/upload", methods=["GET", "POST"], endpoint="upload")
def upload_file():
    if request.method == "POST":
        try:
            # Check if a file is uploaded
            if "file" not in request.files:
                return render_template("upload.html", error="No file uploaded")
            
            file = request.files["file"]
            
            # Check if the file is empty or not an .xlsx file
            if file.filename == "":
                return render_template("upload.html", error="No file selected")
            if not file.filename.lower().endswith(".xlsx"):
                return render_template("upload.html", error="Only .xlsx files are allowed!")
            
            # Generate a unique filename and save the file
            unique_filename = f"{uuid.uuid4().hex}_{file.filename}"
            upload_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(upload_path)
            
            # Read the uploaded Excel file
            df_uploaded = pd.read_excel(upload_path)
            
            # Get data from SQLite (only students table)
            with sqlite3.connect("database.db") as con:
                con.row_factory = sqlite3.Row
                cur = con.cursor()
                cur.execute("""
                    SELECT first_name, second_name, age, gender, email, 
                           school_name, addr, city
                    FROM students
                """)
                db_rows = cur.fetchall()
            
            # Convert SQLite data to DataFrame for easier comparison
            db_df = pd.DataFrame(db_rows, columns=[
                'First Name', 'Second Name', 'Age', 'Gender', 'Email', 
                'School Name', 'Address', 'City'
            ])
            
            # Prepare comparison results
            comparison_results = []
            
            # Define columns to compare (only those in students table)
            student_columns = [
                'First Name', 'Second Name', 'Age', 'Gender', 'Email',
                'School Name', 'Address', 'City'
            ]
            
            # Check if uploaded file has at least the student columns
            if not all(col in df_uploaded.columns for col in student_columns):
                return render_template("upload.html", 
                                     error="Uploaded file is missing required student columns")
            
            # Normalize dataframes (strip strings, handle NaN)
            for col in student_columns:
                if df_uploaded[col].dtype == 'object':
                    df_uploaded[col] = df_uploaded[col].astype(str).str.strip()
                if db_df[col].dtype == 'object':
                    db_df[col] = db_df[col].astype(str).str.strip()
            
            # Replace NaN with empty string for consistent comparison
            df_uploaded = df_uploaded.fillna('')
            db_df = db_df.fillna('')
            
            # Compare each row
            for index, uploaded_row in df_uploaded.iterrows():
                # Try to find matching record in database
                matching_rows = db_df[
                    (db_df['First Name'] == uploaded_row['First Name']) &
                    (db_df['Second Name'] == uploaded_row['Second Name'])
                ]
                
                # Include all columns from uploaded file in results, even if not compared
                row_data = {
                    'First Name': uploaded_row['First Name'],
                    'Second Name': uploaded_row['Second Name'],
                    'Age': uploaded_row['Age'],
                    'Gender': uploaded_row['Gender'],
                    'Email': uploaded_row['Email'],
                    'School Name': uploaded_row['School Name'],
                    'Address': uploaded_row['Address'],
                    'City': uploaded_row['City'],
                }
                
                # Add transaction columns if they exist in the uploaded file
                for col in ['SEL', 'Tran Date', 'Time', 'Code', 'Description']:
                    if col in df_uploaded.columns:
                        row_data[col] = uploaded_row[col]
                
                if not matching_rows.empty:
                    match_row = matching_rows.iloc[0]
                    is_match = True
                    # Compare only student-related columns
                    print(f"\nComparing row {index}:")
                    for col in student_columns:
                        upload_val = str(uploaded_row[col])
                        db_val = str(match_row[col])
                        if upload_val != db_val:
                            print(f"Mismatch in {col}: '{upload_val}' vs '{db_val}'")
                            is_match = False
                    row_data['Result'] = 'Pass' if is_match else 'Fail'
                else:
                    print(f"No match found for {uploaded_row['First Name']} {uploaded_row['Second Name']}")
                    row_data['Result'] = 'Fail'
                
                comparison_results.append(row_data)
            
            # Generate Excel file with results
            result_filename = f"verification_results_{uuid.uuid4().hex}.xlsx"
            result_path = os.path.join(UPLOAD_FOLDER, result_filename)
            result_df = pd.DataFrame(comparison_results)
            result_df.to_excel(result_path, index=False)
            
            # Clean up: remove the temporary uploaded file
            os.remove(upload_path)
            
            # Render the verification results with download link
            return render_template("verifyResult.html", 
                                results=comparison_results,
                                message="Verification completed",
                                download_file=result_filename)
        
        except Exception as e:
            return render_template("upload.html", 
                                error=f"Error processing file: {str(e)}")
    
    # For GET request, render the upload form
    return render_template("upload.html")

# New route to serve the generated Excel file
@app.route("/download/<filename>")
def download_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True)
