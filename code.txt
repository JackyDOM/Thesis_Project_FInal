from flask import Flask, render_template, request
from flask_sqlalchemy import SQLAlchemy
from flask_restx import Api, Resource, fields, Namespace

# Initialize Flask app
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize SQLAlchemy
db = SQLAlchemy(app)

# Initialize Flask-RESTX API
api = Api(app, version='1.0', title='My API', description='A simple API', doc='/swagger/')

# Define the User model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    age = db.Column(db.Integer, nullable=False)
    genre = db.Column(db.String(50), nullable=False)
    dob = db.Column(db.String(50), nullable=False)
    personality = db.Column(db.String(100), nullable=False)
    job = db.Column(db.String(100), nullable=False)
    description = db.Column(db.String(500), nullable=False)

    def __init__(self, name, age, genre, dob, personality, job, description):
        self.name = name
        self.age = age
        self.genre = genre
        self.dob = dob
        self.personality = personality
        self.job = job
        self.description = description

# Create a namespace for User Information
user_ns = Namespace('User_Information', description='Operations related to user information')
api.add_namespace(user_ns)

# Define the user model for Swagger UI input validation
user_input_model = user_ns.model('User', {
    'name': fields.String(required=True, description='Name of the user'),
    'age': fields.Integer(required=True, description='Age of the user'),
    'genre': fields.String(required=True, description='Genre of the user'),
    'dob': fields.String(required=True, description='Date of birth'),
    'personality': fields.String(required=True, description='Personality description'),
    'job': fields.String(required=True, description='Job description'),
    'description': fields.String(required=True, description='Short description of the user')
})

# User Resource for POST (create user)
@user_ns.route('/user')
class UserResource(Resource):
    @user_ns.expect(user_input_model)
    @user_ns.doc('create_user')
    def post(self):
        """Create new user information"""
        data = request.get_json()
        
        # Check if user with the same name already exists
        if User.query.filter_by(name=data['name']).first():
            return {'message': f'User with name {data["name"]} already exists'}, 400
        
        # Create and save the new user
        user = User(
            name=data['name'],
            age=data['age'],
            genre=data['genre'],
            dob=data['dob'],
            personality=data['personality'],
            job=data['job'],
            description=data['description']
        )
        db.session.add(user)
        db.session.commit()
        
        return {'message': f'User {user.name} created successfully'}, 201

# User Resource by ID for GET, PUT, DELETE
@user_ns.route('/user/<int:user_id>')
class UserResourceById(Resource):
    def get(self, user_id):
        """Retrieve user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        return {
            'id': user.id,
            'name': user.name,
            'age': user.age,
            'genre': user.genre,
            'dob': user.dob,
            'personality': user.personality,
            'job': user.job,
            'description': user.description
        }, 200

    @user_ns.expect(user_input_model)
    def put(self, user_id):
        """Update existing user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        data = request.get_json()
        user.name = data['name']
        user.age = data['age']
        user.genre = data['genre']
        user.dob = data['dob']
        user.personality = data['personality']
        user.job = data['job']
        user.description = data['description']
        db.session.commit()
        return {'message': f'User {user_id} updated successfully'}, 200

    def delete(self, user_id):
        """Delete user information"""
        user = User.query.get(user_id)
        if not user:
            return {'message': f'User with ID {user_id} not found'}, 404
        db.session.delete(user)
        db.session.commit()
        return {'message': f'User {user_id} deleted successfully'}, 200

# User List Resource for GET (all users)
@user_ns.route('/users')
class UserList(Resource):
    def get(self):
        """Retrieve all user information"""
        users = User.query.all()
        if not users:
            return {'message': 'No users found', 'code': 404}, 404

        users_list = []
        for user in users:
            users_list.append({
                'id': user.id,
                'name': user.name,
                'age': user.age,
                'genre': user.genre,
                'dob': user.dob,
                'personality': user.personality,
                'job': user.job,
                'description': user.description
            })
        
        response = {
            'message': 'All user information retrieved successfully',
            'code': 200,
            'data': users_list
        }
        return response, 200

# Dashboard route
@app.route('/dashboard')
def dashboard():
    return render_template('layout.html')

# Initialize the database
with app.app_context():
    db.create_all()

if __name__ == '__main__':
    app.run(debug=True)


# @app.route("/delete_uploaded", methods=["POST"])
# def delete_uploaded():
#     try:
#         file_path = request.form.get("file_path")
#         if file_path and os.path.exists(file_path):
#             os.remove(file_path)
#             return render_template("upload.html", message="File deleted successfully")
#         else:
#             return render_template("upload.html", error="File not found")
#     except Exception as e:
#         return render_template("upload.html", error=f"Error deleting file: {str(e)}")

# @app.route("/serve_uploaded_file/<path:file_path>")
# def serve_uploaded_file(file_path):
#     full_path = os.path.join(UPLOAD_FOLDER, file_path)
#     if os.path.exists(full_path):
#         return send_file(full_path, as_attachment=False)  # Opens in browser if supported, or downloads
#     else:
#         return render_template("upload.html", error="File not found")
    

# for verify data when user submit the file xlsx
# @app.route("/verify")
# def verify():
#     return render_template("verifyResult.html")


@app.route("/upload", methods=["GET", "POST"], endpoint="upload")
def upload_file():
    if request.method == "POST":
        try:
            # Check if a file is uploaded
            if "file" not in request.files:
                return render_template("upload.html", error="No file uploaded")
            
            file = request.files["file"]
            
            # Check if the file is empty or not an .xlsx file
            if file.filename == "":
                return render_template("upload.html", error="No file selected")
            if not file.filename.lower().endswith(".xlsx"):
                return render_template("upload.html", error="Only .xlsx files are allowed!")
            
            # Generate a unique filename and save the file
            unique_filename = f"{uuid.uuid4().hex}_{file.filename}"
            upload_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(upload_path)
            
            # Read the uploaded Excel file
            df_uploaded = pd.read_excel(upload_path)
            
            # Get data from SQLite (only students table)
            with sqlite3.connect("database.db") as con:
                con.row_factory = sqlite3.Row
                cur = con.cursor()
                cur.execute("""
                    SELECT first_name, second_name, age, gender, email, 
                           school_name, addr, city
                    FROM students
                """)
                db_rows = cur.fetchall()
            
            # Convert SQLite data to DataFrame for easier comparison
            db_df = pd.DataFrame(db_rows, columns=[
                'First Name', 'Second Name', 'Age', 'Gender', 'Email', 
                'School Name', 'Address', 'City'
            ])
            
            # Prepare comparison results
            comparison_results = []
            
            # Define columns to compare (only those in students table)
            student_columns = [
                'First Name', 'Second Name', 'Age', 'Gender', 'Email',
                'School Name', 'Address', 'City'
            ]
            
            # Check if uploaded file has at least the student columns
            if not all(col in df_uploaded.columns for col in student_columns):
                return render_template("upload.html", 
                                     error="Uploaded file is missing required student columns")
            
            # Normalize dataframes (strip strings, handle NaN)
            for col in student_columns:
                if df_uploaded[col].dtype == 'object':
                    df_uploaded[col] = df_uploaded[col].astype(str).str.strip()
                if db_df[col].dtype == 'object':
                    db_df[col] = db_df[col].astype(str).str.strip()
            
            # Replace NaN with empty string for consistent comparison
            df_uploaded = df_uploaded.fillna('')
            db_df = db_df.fillna('')
            
            # Compare each row
            for index, uploaded_row in df_uploaded.iterrows():
                # Try to find matching record in database
                matching_rows = db_df[
                    (db_df['First Name'] == uploaded_row['First Name']) &
                    (db_df['Second Name'] == uploaded_row['Second Name'])
                ]
                
                # Include all columns from uploaded file in results, even if not compared
                row_data = {
                    'First Name': uploaded_row['First Name'],
                    'Second Name': uploaded_row['Second Name'],
                    'Age': uploaded_row['Age'],
                    'Gender': uploaded_row['Gender'],
                    'Email': uploaded_row['Email'],
                    'School Name': uploaded_row['School Name'],
                    'Address': uploaded_row['Address'],
                    'City': uploaded_row['City'],
                }
                
                # Add transaction columns if they exist in the uploaded file
                for col in ['SEL', 'Tran Date', 'Time', 'Code', 'Description']:
                    if col in df_uploaded.columns:
                        row_data[col] = uploaded_row[col]
                
                if not matching_rows.empty:
                    match_row = matching_rows.iloc[0]
                    is_match = True
                    # Compare only student-related columns
                    print(f"\nComparing row {index}:")
                    for col in student_columns:
                        upload_val = str(uploaded_row[col])
                        db_val = str(match_row[col])
                        if upload_val != db_val:
                            print(f"Mismatch in {col}: '{upload_val}' vs '{db_val}'")
                            is_match = False
                    row_data['Result'] = 'Pass' if is_match else 'Fail'
                else:
                    print(f"No match found for {uploaded_row['First Name']} {uploaded_row['Second Name']}")
                    row_data['Result'] = 'Fail'
                
                comparison_results.append(row_data)
            
            # Generate Excel file with results
            result_filename = f"verification_results_{uuid.uuid4().hex}.xlsx"
            result_path = os.path.join(UPLOAD_FOLDER, result_filename)
            result_df = pd.DataFrame(comparison_results)
            result_df.to_excel(result_path, index=False)
            
            # Clean up: remove the temporary uploaded file
            os.remove(upload_path)
            
            # Render the verification results with download link
            return render_template("verifyResult.html", 
                                results=comparison_results,
                                message="Verification completed",
                                download_file=result_filename)
        
        except Exception as e:
            return render_template("upload.html", 
                                error=f"Error processing file: {str(e)}")
    
    # For GET request, render the upload form
    return render_template("upload.html")

# New route to serve the generated Excel file
@app.route("/download/<filename>")
def download_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True)



============

import cv2
import torch

# Load YOLOv5 model (pre-trained, e.g., 'yolov5s' for small model)
model = torch.hub.load('ultralytics/yolov5', 'yolov5s', pretrained=True)  # Use 'yolov5s', 'yolov5m', 'yolov5l', etc.

# Load the table image
table_image = cv2.imread("C:/Users/MSI/Documents/Thesis_Project/Automste_Testing_DeepSeek_Model/Fine-Tuning-Deep-Seek_R1/static/images/6b4ba075eb7040f2b0e60ea75b4a73c3.png")
if table_image is None:
    print("Error: Could not load the table image.")
    exit()

# Resize the table image for overlay
table_image_resized = cv2.resize(table_image, (400, 200))  # Adjust size as needed

# Set up webcam
cap = cv2.VideoCapture(0)
if not cap.isOpened():
    print("Error: Could not open webcam.")
    exit()

# Run YOLOv5 on the table image to detect objects
# YOLOv5 expects images in RGB format, so convert from BGR
img_rgb = cv2.cvtColor(table_image, cv2.COLOR_BGR2RGB)
results = model(img_rgb)  # Run inference
detections = results.xyxy[0]  # Get bounding boxes (x1, y1, x2, y2, conf, cls)
print(f"Number of detections: {len(detections)}")  # Debug: Check if YOLO detects anything

# Store detected objects with their labels
detected_objects = []
for detection in detections:
    x1, y1, x2, y2, conf, cls = detection  # YOLOv5 output: [x1, y1, x2, y2, confidence, class]
    x1, y1, x2, y2 = map(int, [x1, y1, x2, y2])  # Convert to integers
    conf = conf.item()  # Confidence score
    cls = int(cls.item())  # Class index
    label = model.names[cls]  # Get class name from YOLOv5 model
    print(f"Detection: {label} (confidence: {conf})")  # Debug: Check detected objects and confidence
    if conf > 0.3:  # Confidence threshold
        detected_objects.append((x1, y1, x2, y2, f"{label} ({conf:.2f})"))

# Scale the bounding box coordinates to the resized table image
scale_x = table_image_resized.shape[1] / table_image.shape[1]
scale_y = table_image_resized.shape[0] / table_image.shape[0]
scaled_detections = []
for x1, y1, x2, y2, label in detected_objects:
    x1, x2 = int(x1 * scale_x), int(x2 * scale_x)
    y1, y2 = int(y1 * scale_y), int(y2 * scale_y)
    scaled_detections.append((x1, y1, x2, y2, label))

while True:
    # Capture frame from webcam
    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame.")
        break

    # Overlay the table image on the frame (top-left corner)
    h, w, _ = table_image_resized.shape
    frame_with_table = frame.copy()
    frame_with_table[0:h, 0:w] = table_image_resized

    # Draw bounding boxes and labels on the overlaid table image
    for x1, y1, x2, y2, label in scaled_detections:
        # Draw bounding box
        cv2.rectangle(frame_with_table, (x1, y1), (x2, y2), (0, 255, 0), 2)
        # Draw label above the box
        cv2.putText(frame_with_table, label, (x1, y1 - 10), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    # Display the frame
    cv2.imshow("Webcam with Table and YOLOv5 Detections", frame_with_table)

    # Exit on 'q' key press
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()